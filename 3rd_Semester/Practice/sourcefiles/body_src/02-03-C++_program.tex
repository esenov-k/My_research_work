\chapter{Программная реализация фильтра Калмана}
Рассмотрим реализацию фильтра Калмана на C++ для обработки данных с радаров и камер, обеспечивая улучшенное предсказание положения и скорости объекта \cite{KalmanC++}.

\textbf{Инициализация данных}

В начале необходимо инициализировать вектор состояния, ковариационные матрицы и другие параметры фильтра:

\begin{lstlisting}[language=C++]
// Initialization of the state vector (px, py, vx, vy)
VectorXd x(4);
x << 0, 0, 0, 0;  // Initial state

// Covariance matrix P
MatrixXd P = MatrixXd::Identity(4, 4) * 1000;  // Initial uncertainty

// State transition matrix F
MatrixXd F = MatrixXd::Identity(4, 4);
double dt = 1.0;  // Time step
F(0, 2) = dt;  // Relating px with vx
F(1, 3) = dt;  // Relating py with vy

// Process noise matrix Q
MatrixXd Q = MatrixXd::Zero(4, 4);
double noise_ax = 9.0, noise_ay = 9.0;
Q(0, 0) = Q(1, 1) = 0.5 * dt * dt * noise_ax;
Q(2, 2) = Q(3, 3) = dt * noise_ax;

// Measurement matrix for the camera (measuring px, py)
MatrixXd H_cam(2, 4);
H_cam << 1, 0, 0, 0,
         0, 1, 0, 0;

// Measurement matrix for the radar
MatrixXd H_radar(2, 4);
H_radar << 1, 0, 0, 0,
           0, 1, 0, 0;

// Measurement noise covariance for the camera and radar
MatrixXd R_cam(2, 2);
R_cam << 0.01, 0,
         0, 0.01;

MatrixXd R_radar(2, 2);
R_radar << 0.1, 0,
           0, 0.1;
\end{lstlisting}

\textbf{Функции предсказания и обновления}

Далее описаны функции предсказания состояния и обновления на основе данных с камер и радаров:

\begin{lstlisting}[language=C++]
class KalmanFilter {
public:
    VectorXd x;  // State vector
    MatrixXd P;  // Covariance matrix
    MatrixXd F;  // State transition matrix
    MatrixXd Q;  // Process noise matrix
    MatrixXd H_cam, R_cam;  // Camera matrices
    MatrixXd H_radar, R_radar;  // Radar matrices
    
    KalmanFilter(VectorXd &x_in, MatrixXd &P_in, MatrixXd &F_in, MatrixXd &Q_in,
                 MatrixXd &H_cam_in, MatrixXd &R_cam_in,
                 MatrixXd &H_radar_in, MatrixXd &R_radar_in) {
        x = x_in;
        P = P_in;
        F = F_in;
        Q = Q_in;
        H_cam = H_cam_in;
        R_cam = R_cam_in;
        H_radar = H_radar_in;
        R_radar = R_radar_in;
    }
    
    // State prediction function
    void Predict() {
        x = F * x;  // Predict the state
        P = F * P * F.transpose() + Q;  // Predict the covariance
    }

    // Update based on camera data
    void UpdateCam(const VectorXd &z) {
        VectorXd z_pred = H_cam * x;  // Predicted measurements
        VectorXd y = z - z_pred;  // Error
        MatrixXd S = H_cam * P * H_cam.transpose() + R_cam;
        MatrixXd K = P * H_cam.transpose() * S.inverse();  // Kalman gain
        
        x = x + K * y;  // Update state
        MatrixXd I = MatrixXd::Identity(x.size(), x.size());
        P = (I - K * H_cam) * P;  // Update covariance
    }

    // Update based on radar data
    void UpdateRadar(const VectorXd &z) {
        VectorXd z_pred = H_radar * x;
        VectorXd y = z - z_pred;
        MatrixXd S = H_radar * P * H_radar.transpose() + R_radar;
        MatrixXd K = P * H_radar.transpose() * S.inverse();
        
        x = x + K * y;
        MatrixXd I = MatrixXd::Identity(x.size(), x.size());
        P = (I - K * H_radar) * P;
    }
};
\end{lstlisting}

\textbf{Основной цикл работы алгоритма}

Алгоритм будет предсказывать состояние объекта и обновлять его на основе данных с камеры и радара:

\begin{lstlisting}[language=C++]
int main() {
    // Initialize data
    VectorXd x(4);
    x << 0, 0, 0, 0;

    MatrixXd P = MatrixXd::Identity(4, 4) * 1000;
    MatrixXd F = MatrixXd::Identity(4, 4);
    double dt = 1.0;
    F(0, 2) = dt;
    F(1, 3) = dt;
    
    MatrixXd Q = MatrixXd::Zero(4, 4);
    double noise_ax = 9.0, noise_ay = 9.0;
    Q(0, 0) = Q(1, 1) = 0.5 * dt * dt * noise_ax;
    Q(2, 2) = Q(3, 3) = dt * noise_ax;

    MatrixXd H_cam(2, 4);
    H_cam << 1, 0, 0, 0,
             0, 1, 0, 0;

    MatrixXd R_cam(2, 2);
    R_cam << 0.01, 0,
             0, 0.01;

    MatrixXd H_radar(2, 4);
    H_radar << 1, 0, 0, 0,
               0, 1, 0, 0;

    MatrixXd R_radar(2, 2);
    R_radar << 0.1, 0,
               0, 0.1;

    KalmanFilter kf(x, P, F, Q, H_cam, R_cam, H_radar, R_radar);

    for (int i = 0; i < 10; i++) {
        kf.Predict();

        VectorXd z_cam(2);
        z_cam << 1, 2;
        kf.UpdateCam(z_cam);
        
        VectorXd z_radar(2);
        z_radar << 1.5, 2.5;
        kf.UpdateRadar(z_radar);
        
        std::cout << "Current state x: " << kf.x.transpose() << std::endl;
    }

    return 0;
}
\end{lstlisting}

Данная реализация фильтра Калмана в дальнейшем будет усовершенствоваться под конкретный тип 
данных, получаемых с датчиков. 
